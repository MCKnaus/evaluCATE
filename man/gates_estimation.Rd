% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GATES.R
\name{gates_estimation}
\alias{gates_estimation}
\title{GATES Estimation}
\usage{
gates_estimation(y, D, cates, pscore, mu, mu0, mu1, scores, n_groups = 5)
}
\arguments{
\item{y}{Observed outcomes.}

\item{D}{Treatment indicator.}

\item{cates}{Estimated CATEs. CATEs must be estimated with different observations than those in \code{y} and \code{D}.}

\item{pscore}{Propensity scores. If unknown, they must be estimated using different observations than those in \code{y} and \code{D}.}

\item{mu}{Estimated regression function. It must be estimated with different observations than those in \code{y} and \code{D}.}

\item{mu0}{Estimated regression function for control units. It must be estimated with different observations than those in \code{y} and \code{D}.}

\item{mu1}{Estimated regression function for treated units. It must be estimated with different observations than those in \code{y} and \code{D}.}

\item{scores}{Estimated doubly-robust scores. They must be estimated via K-fold cross-fitting.}

\item{n_groups}{Number of groups to be formed.}
}
\value{
A list of fitted models as \code{\link[estimatr]{lm_robust}} objects.
}
\description{
Estimates the group average treatment effects, with the groups formed by cutting the distribution of the estimated CATEs into K quantiles.
}
\details{
\code{\link{gates_estimation}} estimates the sorted group average treatment effects (GATES). To this end, the user must provide observations on the outcomes and the treatment status of units in 
the validation sample, as well as their estimated cates and nuisance functions. These estimates must be obtained by using only observations from the training sample (see the example section below).\cr

The GATES are estimated using four different strategies: three involving fitting suitable linear models, and one nonparametric approach. Check the 
\href{https://riccardo-df.github.io/evalueCATE/articles/evalue-cates-short-tutorial.html}{online vignette} for details.\cr

For the linear models, standard errors are estimated using the Eicker-Huber-White estimator.\cr

Groups are constructed by cutting the distribution of \code{cates} into \code{n_groups} quantiles. If this leads to one or more groups composed of only treated or only control units, the function raises an error.\cr

The estimated GATES are rearranged to obey the monotonicity property (i.e., we sort them in increasing order).\cr
}
\examples{
## Generate data.
set.seed(1986)

n <- 1000
k <- 2

X <- matrix(rnorm(n * k), ncol = k)
colnames(X) <- paste0("x", seq_len(k))
D <- rbinom(n, size = 1, prob = 0.5)
mu0 <- 0.5 * X[, 1]
mu1 <- 0.5 * X[, 1] + X[, 2]
y <- mu0 + D * (mu1 - mu0) + rnorm(n)

## Sample split.
train_idx <- sample(c(TRUE, FALSE), length(y), replace = TRUE)

X_tr <- X[train_idx, ]
X_val <- X[!train_idx, ]

D_tr <- D[train_idx]
D_val <- D[!train_idx]

y_tr <- y[train_idx]
y_val <- y[!train_idx]

## CATEs and nuisance functions estimation.
library(grf)

cates_forest <- causal_forest(X_tr, y_tr, D_tr) # We use only the training sample.
mu_forest <- regression_forest(X_tr, y_tr)
mu0_forest <- regression_forest(X_tr[D_tr == 0, ], y_tr[D_tr == 0])
mu1_forest <- regression_forest(X_tr[D_tr == 1, ], y_tr[D_tr == 1])

cates_val <- predict(cates_forest, X_val)$predictions # We predict on the validation sample.
mu_val <- predict(mu_forest, X_val)$predictions
mu0_val <- predict(mu0_forest, X_val)$predictions
mu1_val <- predict(mu1_forest, X_val)$predictions

library(aggTrees)
scores_val <- dr_scores(y_val, D_val, X_val)

## GATEs estimation. Here, we know true pscores. Otherwise, estimate them in training sample.
pscore_val <- rep(0.5, length(y_val))
n_groups <- 5
gates_results <- gates_estimation(y_val, D_val, cates_val, 
                                  pscore_val, mu_val, mu0_val, mu1_val, scores_val,
                                  n_groups)

## Compare true GATES with estimated GATES.
model <- gates_results$aipw
cuts <- seq(0, 1, length = n_groups+1)[-c(1, n_groups+1)]
group_indicators <- GenericML::quantile_group(cates_val, cutoffs = cuts)
colnames(group_indicators) <- paste0(1:n_groups)
true_gates <- apply(group_indicators, 2, function(x) {mean(cates_val[x])})

library(ggplot2)

plot_dta <- data.frame("group" = 1:n_groups, "true_gate" = true_gates, 
                       "estimated_gate" = model$coefficients[1:n_groups], 
                       "se" = model$std.error[1:n_groups])

ggplot(plot_dta, aes(x = group, y = true_gate)) +
  geom_point(aes(color = "True")) +
  geom_point(aes(y = estimated_gate, color = "Estimated")) +
  geom_errorbar(aes(x = group, ymin = estimated_gate - 1.96 * se, ymax = estimated_gate + 1.96 * se), color = "black") +
  xlab("Group") + ylab("GATES") + 
  scale_color_manual(name = "", breaks = c("True", "Estimated"), values = c("True" = "tomato", "Estimated" = "dodgerblue")) +
  theme_bw() + 
  theme(legend.position = c(0.2, 0.85))

}
\seealso{
Other functions
}
\author{
Riccardo Di Francesco
}
